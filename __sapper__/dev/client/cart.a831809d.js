import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, Q as removeItem, R as increaseAmount, T as decreaseAmount, e as element, a as space, t as text, f as claim_element, g as children, c as claim_space, h as claim_text, b as detach_dev, j as attr_dev, k as add_location, l as insert_dev, m as append_dev, I as listen_dev, J as set_data_dev, n as noop, O as run_all, v as validate_each_argument, o as validate_each_keys, p as validate_store, U as cart, r as component_subscribe, V as cartTotal, W as afterUpdate, X as setStorageCart, Y as assign, u as empty, x as create_component, y as claim_component, z as mount_component, Z as get_spread_update, _ as get_spread_object, A as transition_in, B as transition_out, C as destroy_component, D as group_outros, E as update_keyed_each, F as check_outros, G as outro_and_destroy_block, $ as globalStore, a0 as user } from './client.c6aaad23.js';
import { u as url } from './URL.a6a1c5b8.js';

/* src/components/Cart/Item.svelte generated by Svelte v3.19.0 */
const file = "src/components/Cart/Item.svelte";

function create_fragment(ctx) {
	let div3;
	let div1;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let h4;
	let t1;
	let t2;
	let h5;
	let t3;
	let t4;
	let t5;
	let button0;
	let t6;
	let t7;
	let div2;
	let button1;
	let t8;
	let t9;
	let p;
	let t10;
	let t11;
	let button2;
	let t12;
	let dispose;

	const block = {
		c: function create() {
			div3 = element("div");
			div1 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			h4 = element("h4");
			t1 = text(/*title*/ ctx[2]);
			t2 = space();
			h5 = element("h5");
			t3 = text("$");
			t4 = text(/*price*/ ctx[3]);
			t5 = space();
			button0 = element("button");
			t6 = text("remove");
			t7 = space();
			div2 = element("div");
			button1 = element("button");
			t8 = text("increase");
			t9 = space();
			p = element("p");
			t10 = text(/*amount*/ ctx[4]);
			t11 = space();
			button2 = element("button");
			t12 = text("decrease");
			this.h();
		},
		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			img = claim_element(div1_nodes, "IMG", { src: true, alt: true, class: true });
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			h4 = claim_element(div0_nodes, "H4", {});
			var h4_nodes = children(h4);
			t1 = claim_text(h4_nodes, /*title*/ ctx[2]);
			h4_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);
			h5 = claim_element(div0_nodes, "H5", {});
			var h5_nodes = children(h5);
			t3 = claim_text(h5_nodes, "$");
			t4 = claim_text(h5_nodes, /*price*/ ctx[3]);
			h5_nodes.forEach(detach_dev);
			t5 = claim_space(div0_nodes);
			button0 = claim_element(div0_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t6 = claim_text(button0_nodes, "remove");
			button0_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t7 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			button1 = claim_element(div2_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t8 = claim_text(button1_nodes, "increase");
			button1_nodes.forEach(detach_dev);
			t9 = claim_space(div2_nodes);
			p = claim_element(div2_nodes, "P", { class: true });
			var p_nodes = children(p);
			t10 = claim_text(p_nodes, /*amount*/ ctx[4]);
			p_nodes.forEach(detach_dev);
			t11 = claim_space(div2_nodes);
			button2 = claim_element(div2_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t12 = claim_text(button2_nodes, "decrease");
			button2_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = `${url}${/*image*/ ctx[1][0].url}`)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", /*title*/ ctx[2]);
			attr_dev(img, "class", "svelte-1ka4bc1");
			add_location(img, file, 23, 4, 447);
			add_location(h4, file, 25, 6, 534);
			add_location(h5, file, 26, 6, 557);
			add_location(button0, file, 27, 6, 581);
			attr_dev(div0, "class", "item-content");
			add_location(div0, file, 24, 4, 501);
			attr_dev(div1, "class", "item svelte-1ka4bc1");
			add_location(div1, file, 22, 2, 424);
			add_location(button1, file, 37, 4, 738);
			attr_dev(p, "class", "item-amount");
			add_location(p, file, 43, 4, 841);
			add_location(button2, file, 44, 4, 881);
			attr_dev(div2, "class", "item-options");
			add_location(div2, file, 36, 2, 707);
			attr_dev(div3, "class", "item-wrapper");
			add_location(div3, file, 21, 0, 395);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div1);
			append_dev(div1, img);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, h4);
			append_dev(h4, t1);
			append_dev(div0, t2);
			append_dev(div0, h5);
			append_dev(h5, t3);
			append_dev(h5, t4);
			append_dev(div0, t5);
			append_dev(div0, button0);
			append_dev(button0, t6);
			append_dev(div3, t7);
			append_dev(div3, div2);
			append_dev(div2, button1);
			append_dev(button1, t8);
			append_dev(div2, t9);
			append_dev(div2, p);
			append_dev(p, t10);
			append_dev(div2, t11);
			append_dev(div2, button2);
			append_dev(button2, t12);

			dispose = [
				listen_dev(button0, "click", /*click_handler*/ ctx[5], false, false, false),
				listen_dev(button1, "click", /*click_handler_1*/ ctx[6], false, false, false),
				listen_dev(button2, "click", /*click_handler_2*/ ctx[7], false, false, false)
			];
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*image*/ 2 && img.src !== (img_src_value = `${url}${/*image*/ ctx[1][0].url}`)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*title*/ 4) {
				attr_dev(img, "alt", /*title*/ ctx[2]);
			}

			if (dirty & /*title*/ 4) set_data_dev(t1, /*title*/ ctx[2]);
			if (dirty & /*price*/ 8) set_data_dev(t4, /*price*/ ctx[3]);
			if (dirty & /*amount*/ 16) set_data_dev(t10, /*amount*/ ctx[4]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { id } = $$props;
	let { image } = $$props;
	let { title } = $$props;
	let { price } = $$props;
	let { amount } = $$props;
	const writable_props = ["id", "image", "title", "price", "amount"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Item> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		removeItem(id);
	};

	const click_handler_1 = () => {
		increaseAmount(id);
	};

	const click_handler_2 = () => {
		decreaseAmount(id);
	};

	$$self.$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("image" in $$props) $$invalidate(1, image = $$props.image);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("price" in $$props) $$invalidate(3, price = $$props.price);
		if ("amount" in $$props) $$invalidate(4, amount = $$props.amount);
	};

	$$self.$capture_state = () => ({
		id,
		image,
		title,
		price,
		amount,
		url,
		removeItem,
		increaseAmount,
		decreaseAmount
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("image" in $$props) $$invalidate(1, image = $$props.image);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("price" in $$props) $$invalidate(3, price = $$props.price);
		if ("amount" in $$props) $$invalidate(4, amount = $$props.amount);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		id,
		image,
		title,
		price,
		amount,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class Item extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			id: 0,
			image: 1,
			title: 2,
			price: 3,
			amount: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Item",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
			console.warn("<Item> was created without expected prop 'id'");
		}

		if (/*image*/ ctx[1] === undefined && !("image" in props)) {
			console.warn("<Item> was created without expected prop 'image'");
		}

		if (/*title*/ ctx[2] === undefined && !("title" in props)) {
			console.warn("<Item> was created without expected prop 'title'");
		}

		if (/*price*/ ctx[3] === undefined && !("price" in props)) {
			console.warn("<Item> was created without expected prop 'price'");
		}

		if (/*amount*/ ctx[4] === undefined && !("amount" in props)) {
			console.warn("<Item> was created without expected prop 'amount'");
		}
	}

	get id() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get image() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set image(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get price() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set price(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get amount() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set amount(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Cart/ItemList.svelte generated by Svelte v3.19.0 */
const file$1 = "src/components/Cart/ItemList.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	child_ctx[4] = i;
	return child_ctx;
}

// (15:2) {:else}
function create_else_block(ctx) {
	let h2;
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text("empty cart");
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, "empty cart");
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file$1, 15, 4, 323);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(15:2) {:else}",
		ctx
	});

	return block;
}

// (13:2) {#each $cart as cartItem, index (cartItem.id)}
function create_each_block(key_1, ctx) {
	let first;
	let current;
	const item_spread_levels = [/*cartItem*/ ctx[2]];
	let item_props = {};

	for (let i = 0; i < item_spread_levels.length; i += 1) {
		item_props = assign(item_props, item_spread_levels[i]);
	}

	const item = new Item({ props: item_props, $$inline: true });

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(item.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(item.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item_changes = (dirty & /*$cart*/ 1)
			? get_spread_update(item_spread_levels, [get_spread_object(/*cartItem*/ ctx[2])])
			: {};

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(13:2) {#each $cart as cartItem, index (cartItem.id)}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t0;
	let div0;
	let h3;
	let t1;
	let t2;
	let current;
	let each_value = /*$cart*/ ctx[0];
	validate_each_argument(each_value);
	const get_key = ctx => /*cartItem*/ ctx[2].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	let each_1_else = null;

	if (!each_value.length) {
		each_1_else = create_else_block(ctx);
	}

	const block = {
		c: function create() {
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			if (each_1_else) {
				each_1_else.c();
			}

			t0 = space();
			div0 = element("div");
			h3 = element("h3");
			t1 = text("total: $");
			t2 = text(/*$cartTotal*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", {});
			var div1_nodes = children(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			if (each_1_else) {
				each_1_else.l(div1_nodes);
			}

			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", {});
			var div0_nodes = children(div0);
			h3 = claim_element(div0_nodes, "H3", {});
			var h3_nodes = children(h3);
			t1 = claim_text(h3_nodes, "total: $");
			t2 = claim_text(h3_nodes, /*$cartTotal*/ ctx[1]);
			h3_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file$1, 19, 4, 366);
			add_location(div0, file$1, 18, 2, 356);
			add_location(div1, file$1, 11, 0, 227);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			if (each_1_else) {
				each_1_else.m(div1, null);
			}

			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, h3);
			append_dev(h3, t1);
			append_dev(h3, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$cart*/ 1) {
				const each_value = /*$cart*/ ctx[0];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block, t0, get_each_context);
				check_outros();
			}

			if (each_value.length) {
				if (each_1_else) {
					each_1_else.d(1);
					each_1_else = null;
				}
			} else if (!each_1_else) {
				each_1_else = create_else_block(ctx);
				each_1_else.c();
				each_1_else.m(div1, t0);
			}

			if (!current || dirty & /*$cartTotal*/ 2) set_data_dev(t2, /*$cartTotal*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (each_1_else) each_1_else.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $cart;
	let $cartTotal;
	validate_store(cart, "cart");
	component_subscribe($$self, cart, $$value => $$invalidate(0, $cart = $$value));
	validate_store(cartTotal, "cartTotal");
	component_subscribe($$self, cartTotal, $$value => $$invalidate(1, $cartTotal = $$value));

	afterUpdate(() => {
		setStorageCart($cart);
	});

	$$self.$capture_state = () => ({
		Item,
		cart,
		cartTotal,
		setStorageCart,
		afterUpdate,
		$cart,
		$cartTotal
	});

	return [$cart, $cartTotal];
}

class ItemList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ItemList",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/cart.svelte generated by Svelte v3.19.0 */
const file$2 = "src/routes/cart.svelte";

// (16:4) {:else}
function create_else_block$1(ctx) {
	let p;
	let t0;
	let t1;
	let a;
	let t2;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("login to checkout");
			t1 = space();
			a = element("a");
			t2 = text("login");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "login to checkout");
			p_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			a = claim_element(nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t2 = claim_text(a_nodes, "login");
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "cart-login");
			add_location(p, file$2, 16, 6, 387);
			attr_dev(a, "href", "login");
			attr_dev(a, "class", "login");
			add_location(a, file$2, 17, 6, 437);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, a, anchor);
			append_dev(a, t2);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(16:4) {:else}",
		ctx
	});

	return block;
}

// (14:4) {#if $user}
function create_if_block(ctx) {
	let a;
	let t;

	const block = {
		c: function create() {
			a = element("a");
			t = text("checkout");
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, "checkout");
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "checkout");
			attr_dev(a, "class", "checkout");
			add_location(a, file$2, 14, 6, 320);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(14:4) {#if $user}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let current;
	const itemlist = new ItemList({ $$inline: true });

	function select_block_type(ctx, dirty) {
		if (/*$user*/ ctx[0]) return create_if_block;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			create_component(itemlist.$$.fragment);
			t = space();
			div1 = element("div");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(itemlist.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "cart-items");
			add_location(div0, file$2, 9, 2, 219);
			attr_dev(div1, "class", "cart-footer");
			add_location(div1, file$2, 12, 2, 272);
			attr_dev(div2, "class", "cart");
			add_location(div2, file$2, 8, 0, 198);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			mount_component(itemlist, div0, null);
			append_dev(div2, t);
			append_dev(div2, div1);
			if_block.m(div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div1, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemlist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemlist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(itemlist);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $user;
	validate_store(user, "user");
	component_subscribe($$self, user, $$value => $$invalidate(0, $user = $$value));
	$$self.$capture_state = () => ({ globalStore, user, ItemList, $user });
	return [$user];
}

class Cart extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Cart",
			options,
			id: create_fragment$2.name
		});
	}
}

export default Cart;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FydC5hODMxODA5ZC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQ2FydC9JdGVtLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0NhcnQvSXRlbUxpc3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9jYXJ0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGlkO1xuICBleHBvcnQgbGV0IGltYWdlO1xuICBleHBvcnQgbGV0IHRpdGxlO1xuICBleHBvcnQgbGV0IHByaWNlO1xuICBleHBvcnQgbGV0IGFtb3VudDtcblxuICBpbXBvcnQgdXJsIGZyb20gXCIuLi8uLi9zdHJhcGkvVVJMLmpzXCI7XG5cbiAgaW1wb3J0IHtcbiAgICByZW1vdmVJdGVtLFxuICAgIGluY3JlYXNlQW1vdW50LFxuICAgIGRlY3JlYXNlQW1vdW50XG4gIH0gZnJvbSBcIi4uLy4uL3N0b3Jlcy9jYXJ0LmpzXCI7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4gIC5pdGVtIHtcbiAgICBpbWcge1xuICAgICAgaGVpZ2h0OiAxNTBweDtcbiAgICAgIHdpZHRoOiAxNTBweDtcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJpdGVtLXdyYXBwZXJcIj5cbiAgPGRpdiBjbGFzcz1cIml0ZW1cIj5cbiAgICA8aW1nIHNyYz17YCR7dXJsfSR7aW1hZ2VbMF0udXJsfWB9IGFsdD17dGl0bGV9IC8+XG4gICAgPGRpdiBjbGFzcz1cIml0ZW0tY29udGVudFwiPlxuICAgICAgPGg0Pnt0aXRsZX08L2g0PlxuICAgICAgPGg1PiR7cHJpY2V9PC9oNT5cbiAgICAgIDxidXR0b25cbiAgICAgICAgb246Y2xpY2s9eygpID0+IHtcbiAgICAgICAgICByZW1vdmVJdGVtKGlkKTtcbiAgICAgICAgfX0+XG4gICAgICAgIHJlbW92ZVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxkaXYgY2xhc3M9XCJpdGVtLW9wdGlvbnNcIj5cbiAgICA8YnV0dG9uXG4gICAgICBvbjpjbGljaz17KCkgPT4ge1xuICAgICAgICBpbmNyZWFzZUFtb3VudChpZCk7XG4gICAgICB9fT5cbiAgICAgIGluY3JlYXNlXG4gICAgPC9idXR0b24+XG4gICAgPHAgY2xhc3M9XCJpdGVtLWFtb3VudFwiPnthbW91bnR9PC9wPlxuICAgIDxidXR0b25cbiAgICAgIG9uOmNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGRlY3JlYXNlQW1vdW50KGlkKTtcbiAgICAgIH19PlxuICAgICAgZGVjcmVhc2VcbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBJdGVtIGZyb20gXCIuL0l0ZW0uc3ZlbHRlXCI7XG4gIGltcG9ydCBjYXJ0LCB7IGNhcnRUb3RhbCwgc2V0U3RvcmFnZUNhcnQgfSBmcm9tIFwiLi4vLi4vc3RvcmVzL2NhcnQuanNcIjtcblxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gXCJzdmVsdGVcIjtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgc2V0U3RvcmFnZUNhcnQoJGNhcnQpO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48ZGl2PlxuICB7I2VhY2ggJGNhcnQgYXMgY2FydEl0ZW0sIGluZGV4IChjYXJ0SXRlbS5pZCl9XG4gICAgPEl0ZW0gey4uLmNhcnRJdGVtfSAvPlxuICB7OmVsc2V9XG4gICAgPGgyPmVtcHR5IGNhcnQ8L2gyPlxuICB7L2VhY2h9XG5cbiAgPGRpdj5cbiAgICA8aDM+dG90YWw6ICR7JGNhcnRUb3RhbH08L2gzPlxuICA8L2Rpdj5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IGdsb2JhbFN0b3JlIGZyb20gXCIuLi9zdG9yZXMvZ2xvYmFsU3RvcmUuanNcIjtcbiAgaW1wb3J0IHVzZXIgZnJvbSBcIi4uL3N0b3Jlcy91c2VyLmpzXCI7XG4gIGltcG9ydCBJdGVtTGlzdCBmcm9tIFwiLi4vY29tcG9uZW50cy9DYXJ0L0l0ZW1MaXN0LnN2ZWx0ZVwiO1xuXG4gIC8vbGV0IHVzZXIgPSBmYWxzZTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiY2FydFwiPlxuICA8ZGl2IGNsYXNzPVwiY2FydC1pdGVtc1wiPlxuICAgIDxJdGVtTGlzdCAvPlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cImNhcnQtZm9vdGVyXCI+XG4gICAgeyNpZiAkdXNlcn1cbiAgICAgIDxhIGhyZWY9XCJjaGVja291dFwiIGNsYXNzPVwiY2hlY2tvdXRcIj5jaGVja291dDwvYT5cbiAgICB7OmVsc2V9XG4gICAgICA8cCBjbGFzcz1cImNhcnQtbG9naW5cIj5sb2dpbiB0byBjaGVja291dDwvcD5cbiAgICAgIDxhIGhyZWY9XCJsb2dpblwiIGNsYXNzPVwibG9naW5cIj5sb2dpbjwvYT5cbiAgICB7L2lmfVxuICA8L2Rpdj5cbjwvZGl2PlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkF5QlcsR0FBSzs7Ozt1QkFDSixHQUFLOzs7Ozs7Ozs7O3lCQWlCVyxHQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FsQnZCLEdBQUs7Ozs7Ozt1Q0FDSixHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQWlCVyxHQUFNOzs7Ozs7Ozs7Ozs7dUNBcEJqQixHQUFHLGFBQUcsR0FBSyxJQUFDLENBQUMsRUFBRSxHQUFHO2tDQUFTLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OERBQWhDLEdBQUcsYUFBRyxHQUFLLElBQUMsQ0FBQyxFQUFFLEdBQUc7Ozs7O21DQUFTLEdBQUs7Ozt1REFFdEMsR0FBSzt1REFDSixHQUFLOzJEQWlCVyxHQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMUNyQixFQUFFO09BQ0YsS0FBSztPQUNMLEtBQUs7T0FDTCxLQUFLO09BQ0wsTUFBTTs7Ozs7Ozs7RUF3QlQsVUFBVSxDQUFDLEVBQUU7Ozs7RUFVZixjQUFjLENBQUMsRUFBRTs7OztFQU9qQixjQUFjLENBQUMsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQ2pDWCxHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyRUFBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0QkFEYixHQUFLOztxQ0FBcUIsR0FBUSxJQUFDLEVBQUU7OztnQ0FBMUMsTUFBSTs7Ozs7Ozs7aUJBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBT1MsR0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRDQUFWLEdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBUGxCLEdBQUs7Ozs7Ozs7O2tCQUFWLE1BQUk7Ozs7Ozs7Ozs7OzZFQU9TLEdBQVU7Ozs7O2tDQVB2QixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBTk4sV0FBVztFQUNULGNBQWMsQ0FBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkNNZixHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
